
local plrs=game:FindFirstChildOfClass("Players")
local rs=game:FindFirstChildOfClass("RunService")
local ws=game:FindFirstChildOfClass("Workspace")
local uis=game:FindFirstChildOfClass("UserInputService")
local gs=game:FindFirstChildOfClass("GuiService")
local lp=plrs.LocalPlayer
local pg=lp:FindFirstChildOfClass("PlayerGui")
local mouse=lp:GetMouse()
local stepped=rs.Stepped
local heartbeat=rs.Heartbeat
local renderstepped=rs.RenderStepped

local osclock=os.clock
local tspawn=task.spawn
local twait=task.wait
local schar=string.char
local ssub=string.sub
local sfind=string.find
local supper=string.upper
local mrandom=math.random
local clamp=math.clamp
local sin=math.sin
local cos=math.cos
local abs=math.abs
local rad=math.rad
local tinsert=table.insert
local tclear=table.clear
local tclone=table.clone
local tfind=table.find
local tunpack=table.unpack

--the loops dont have to read globals to get the "pairs" or "next" variable every time
local pairs=pairs 
local next=next

local i=Instance.new 
local v2=Vector2.new 
local v3=Vector3.new
local c3=Color3.new 
local cf=CFrame.new
local angles=CFrame.Angles
local u2=UDim2.new
local e=Enum 
local cs=ColorSequence.new 
local csk=ColorSequenceKeypoint.new 

local sine=osclock()
local deltaTime=0
local v3_0=v3(0,0,0)
local v3_101=v3(1,0,1)
local v3_010=v3(0,1,0)
local v3_001=v3(0,0,1)
local cf_0=cf(0,0,0)
local v3_xz=v3_101*10
local v3_net=v3_010*25.01

local function makepcall(f)
	if type(f)=="function" then
		return function(...)
			local a={...}
			local r=nil
			pcall(function()
				r={f(tunpack(a))}
			end)
			return tunpack(r or {})
		end
	end
	return function() end
end
local function rs(l) 
	l=l or mrandom(8,15) 
	local s="" 
	for i=1,l do 
		if mrandom(1,2)==1 then 
			s=s..schar(mrandom(65,90)) 
		else 
			s=s..schar(mrandom(97,122)) 
		end 
	end 
	return s 
end 
local function dfind(t,v)
	for i,v1 in pairs(t) do
		if v1==v then
			return i
		end
	end
	return nil
end
local function gp(p,n,cl)
	if typeof(p)=="Instance" then
		local c=p:GetChildren()
		for i=1,#c do
			local v=c[i]
			if (v.Name==n) and v:IsA(cl) then
				return v
			end
		end
	end
	return nil
end
local function timegp(p,n,c,t)
	t=osclock()+t
	while t>osclock() do
		local r=gp(p,n,c)
		if r then
			return r
		end
		stepped:Wait()
	end
	return nil
end
local function getNetlessVelocity(realVel)
	--if true then return v3_0 end
	--if true then return realPartVelocity end
	--if true then return v3_net end
	if realVel.Magnitude>25.01 then
		realVel=realVel.Unit*25.01
	end
	return realVel*v3_xz+v3_net
end
local sft=1/60
local function getFallingTime(startY,destY,gravity)
	local velY=25.01
	local currY=startY
	local fallingTime=0
	while (currY>destY) or (velY>0) do
		fallingTime=fallingTime+sft
		velY=velY-sft*gravity
		currY=currY+velY*sft
	end
	return fallingTime
end
local function getMeshOfPart(v)
	if typeof(v)=="Instance" then
		if v:IsA("MeshPart") then
			return v.MeshId, v.TextureID
		else
			v=v:FindFirstChildOfClass("SpecialMesh")
			if v then
				return v.MeshId, v.TextureId
			end
		end
	end
	return nil, nil
end
local function makeplaceholder(v)
	if typeof(v)~="Instance" then
		return nil
	end
	if not v.Archivable then
		v.Archivable=true
	end
	v=v:Clone()
	local c=v:GetChildren()
	for i=1,#c do
		local v=c[i]
		if v:IsA("SpecialMesh") then
			v.Name=rs()
			v:ClearAllChildren()
		else
			v:Destroy()
		end
	end
	v.Name=rs()
	v.Anchored=true
	v.CanCollide=false
	v.Transparency=0.25
	v.Parent=ws
	return v
end
local function emptyfunction() end

--it runs even faster if u call __index and __newindex of metatables of userdata directly
local function getMetamethodFromErrorStack(userdata,f,test)
	local ret=nil
	xpcall(f,function()
		ret=debug.info(2,"f")
	end,userdata,nil,0)
	if (type(ret)~="function") or not test(ret) then
		return f
	end
	return ret
end
local cfGet=getMetamethodFromErrorStack(cf_0,function(a,b) return a[b] end,function(f) return f(cf(1,2,3),"Position")==v3(1,2,3) end)
local cfMul=getMetamethodFromErrorStack(cf_0,function(a,b) return a*b end,function(f) return angles(1,2,3)*angles(1,2,3)==f(angles(1,2,3),angles(1,2,3)) end)
local Inverse=cfGet(cf_0,"Inverse")
local Lerp=cfGet(cf_0,"Lerp")

local guiTheme={
	guiTitle="patchma",
	windowTitleColor=c3(0.5,0.5,0),
	windowTopColor=c3(0.5,0.5,0),
	windowBottomColor=c3(0,0,0.584314),
	windowMinimizedSize=u2(0,220,0,22),
	windowRegularSize=u2(0,220,0,240),
	buttonsTextColor=c3(5.0,5.0,0.),
	labelsTextColor=c3(0.560784,0.560784,0.560784),
	listTopColor=c3(0.5,0.5,0),
	listBottomColor=c3(0.0705882,0.0705882,0.0705882)
}

local accessorylimbs={

	{meshid="11263221350",textureid="11263219250",C0=angles(1.5707963267948966,0,1.5707963267948966),Name="Left Arm"},
	{meshid="11159370334",textureid="11159284657",C0=angles(-1.5707963267948966,0,1.5707963267948966),Name="Right Arm"},

	{meshid="14255522247",textureid="",C0=angles(1.5707963267948966,0,1.5707963267948966),Name="Left Arm"},
	{meshid="14255522247",textureid="",C0=angles(-1.5707963267948966,0,1.5707963267948966),Name="Right Arm"},

	{meshid="12344207333",textureid="",C0=angles(2,0,0),Name="Left Arm"},
	{meshid="12344206657",textureid="",C0=angles(2,0,0),Name="Right Arm"},

	{meshid="11159370334",textureid="11159285454",C0=angles(1.5707963267948966,0,1.5707963267948966),Name="Left Leg"},
	{meshid="12652772399",textureid="12652775021",C0=cf(0,-0.125,0),Name="Right Leg"},

	{meshid="14768684979",textureid="",C0=angles(0,0,1.5707963267948966),Name="Left Leg"},
	{meshid="14768684979",textureid="",C0=angles(0,0,1.5707963267948966),Name="Right Leg"},

	{meshid="14768666349",textureid="",C0=cf_0,Name="Torso"},
	{meshid="14241018198",textureid="",C0=cf_0,Name="Torso"},
	{meshid="13421774668",textureid="",C0=cf_0,Name="Torso"},

	{meshid="4324138105",textureid="4324138210",C0=angles(-1.6144295580947547,1.5707963267948966,0)*cf(-0.125,0.3,0),Name="Left Arm"},
	{meshid="4154474745",textureid="4154474807",C0=angles(1.5271630954950384,-1.5707963267948966,0)*cf(-0.125,-0.3,0),Name="Left Arm"},
	{meshid="3030546036",textureid="3650191503",C0=angles(1.5271630954950384,1.5707963267948966,0)*cf(0.125,-0.3,0),Name="Right Arm"},
	{meshid="3030546036",textureid="3443321249",C0=angles(-1.6144295580947547,-1.5707963267948966,0)*cf(0.125,0.3,0),Name="Right Arm"},
	{meshid="3030546036",textureid="3360974849",C0=angles(1.5271630954950384,1.5707963267948966,0)*cf(-0.125,-0.35,0),Name="Left Leg"},
	{meshid="3030546036",textureid="3360978739",C0=angles(-1.6144295580947547,-1.5707963267948966,0)*cf(-0.125,0.3,0),Name="Left Leg"},
	{meshid="3030546036",textureid="3033898741",C0=angles(1.5271630954950384,-1.5707963267948966,0)*cf(0.125,-0.35,0),Name="Right Leg"},
	{meshid="3030546036",textureid="3409604993",C0=angles(-1.6144295580947547,1.5707963267948966,0)*cf(0.125,0.3,0),Name="Right Leg"},
	{meshid="4819720316",textureid="4819722776",C0=angles(0,0,0.2617993877991494),Name="Torso"}
}

local i1=i("Frame") 
local i2=i("Frame") 
local i3=i("ScrollingFrame") 
local i4=i("UIListLayout") 
local i5=i("UIGradient") 
local i6=i("TextBox") 
local i7=i("TextButton") 
local i8=i("UIGradient") 
local i9=i("ScreenGui") 
i1.AnchorPoint=v2(0.5,0) 
i1.BackgroundColor3=c3(0.5,0.5,0) 
i1.BorderSizePixel=0 
i1.Position=u2(0.5,0,0.4,-150) 
i1.Size=guiTheme.windowRegularSize 
i1.Name=rs() 
i1.Parent=i9 
i2.BackgroundColor3=c3(1,0.5,0) 
i2.BorderSizePixel=0 
i2.Position=u2(0,5,0,20) 
i2.Size=u2(1,-10,0.4,-25) 
i2.Name=rs() 
i2.Parent=i1 
i3.Active=true 
i3.BackgroundTransparency=1 
i3.BorderSizePixel=0 
i3.Size=u2(1,-3,1,0) 
i3.AutomaticCanvasSize=e.AutomaticSize.Y 
i3.CanvasSize=u2(0,0,0,0) 
i3.ScrollBarThickness=0 
i3.Name=rs() 
i3.Parent=i2 
i4.Name=rs() 
i4.Parent=i3 
i4.SortOrder=e.SortOrder.LayoutOrder 
i5.Name=rs() 
i5.Parent=i2 
i5.Color=cs({[1]=csk(0,guiTheme.listTopColor),[2]=csk(1,guiTheme.listBottomColor)}) 
i5.Rotation=90 
i6.Font=e.Font.SourceSans 
i6.FontSize=e.FontSize.Size18 
i6.ClearTextOnFocus=false 
i6.Text=guiTheme.guiTitle 
i6.TextColor3=guiTheme.windowTitleColor 
i6.TextSize=20 
i6.AnchorPoint=v2(0.5,0) 
i6.BackgroundTransparency=1 
i6.Position=u2(0.5,0,0,11) 
i6.Name=rs() 
i6.Parent=i1 
i7.AnchorPoint=v2(1,0) 
i7.BackgroundTransparency=1 
i7.Position=u2(1,0,0,0) 
i7.Size=u2(0,40,0,20) 
i7.Name=rs() 
i7.Parent=i1 
i7.Font=e.Font.SourceSans 
i7.FontSize=e.FontSize.Size18 
i7.Text="-" 
i7.TextColor3=c3(1,0,0) 
i7.TextSize=20 
i8.Name=rs() 
i8.Parent=i1 
i8.Color=cs({[1]=csk(0,guiTheme.windowTopColor),[2]=csk(1,guiTheme.windowBottomColor)}) 
i8.Rotation=90 
i9.ZIndexBehavior=e.ZIndexBehavior.Sibling 
i9.IgnoreGuiInset=true 
i9.ResetOnSpawn=false 
i9.DisplayOrder=2147483647 
i9.Name=rs() 
local min=false
i7.MouseButton1Click:Connect(function()
	min = not min
	if min then
		i2.Visible=false 
		i8.Color=cs({[1]=csk(0,c3(0,0,0)),[2]=csk(1,c3(0,0,0))}) 
		i1.Size=guiTheme.windowMinimizedSize 
	else
		i1.Size=guiTheme.windowRegularSize 
		i8.Color=cs({[1]=csk(0,c3(0,0,0)),[2]=csk(1,c3(0,0,0.584314))}) 
		i2.Visible=false 
	end
end)
local function Draggable(window,obj)
	local MB1enum = e.UserInputType.MouseButton1
	local TOUCHenum = e.UserInputType.Touch
	obj = obj or window
	local activeEntered = 0
	local mouseStart = nil
	local dragStart = nil
	local inputbegancon = nil
	local rendersteppedcon = nil
	local inputendedcon = nil
	local function inputendedf(a)
		a=a.UserInputType
		if (a==MB1enum) or (a==TOUCHenum) then
			rendersteppedcon:Disconnect()
			inputendedcon:Disconnect()
		end
	end
	local function rendersteppedf()
		local off = uis:GetMouseLocation()-mouseStart
		window.Position=dragStart+u2(0,off.X,0,off.Y)
	end
	local function inputbeganf(a)
		a=a.UserInputType
		if ((a==MB1enum) or (a==TOUCHenum)) and (activeEntered==0) and not uis:GetFocusedTextBox() then
			mouseStart=uis:GetMouseLocation()
			dragStart=window.Position
			if rendersteppedcon then rendersteppedcon:Disconnect() end
			rendersteppedcon = renderstepped:Connect(rendersteppedf)
			if inputendedcon then inputendedcon:Disconnect() end
			inputendedcon = uis.InputEnded:Connect(inputendedf)
		end
	end
	obj.MouseEnter:Connect(function()
		if inputbegancon then inputbegancon:Disconnect() end
		inputbegancon = uis.InputBegan:Connect(inputbeganf)
	end)
	obj.MouseLeave:Connect(function()
		inputbegancon:Disconnect()
	end)
	local function ondes(d)
		if d:IsA("GuiObject") then
			local thisEntered = false
			local thisAdded = false
			local con0 = d.MouseEnter:Connect(function()
				thisEntered = true
				if (not thisAdded) and d.Active then
					activeEntered = activeEntered + 1
					thisAdded = true
				end
			end)
			local con1 = d.MouseLeave:Connect(function()
				thisEntered = false
				if thisAdded then
					activeEntered = activeEntered - 1
					thisAdded = false
				end
			end)
			local con2 = d:GetPropertyChangedSignal("Active"):Connect(function()
				if thisEntered then
					if thisAdded and not d.Active then
						activeEntered = activeEntered - 1
						thisAdded = false
					elseif d.Active and not thisAdded then
						activeEntered = activeEntered + 1
						thisAdded = true
					end
				end
			end)
			local con3 = nil
			con3 = d.AncestryChanged:Connect(function()
				if not d:IsDescendantOf(window) then
					if thisEntered then
						activeEntered = activeEntered - 1
					end
					con0:Disconnect()
					con1:Disconnect()
					con2:Disconnect()
					con3:Disconnect()
				end
			end)
		end
	end
	window.DescendantAdded:Connect(ondes)
	local des=window:GetDescendants()
	for i=1,#des do 
		ondes(des[i])
	end
end
local function btn(txt, f)
	local i1=i("TextBox") 
	local i2=i("TextButton")
	i1.Font=e.Font.SourceSans 
	i1.FontSize=e.FontSize.Size14 
	i1.Text=txt 
	i1.ClearTextOnFocus=false 
	i1.Position=u2(0.5,0,0.5,0) 
	i1.TextColor3=guiTheme.buttonsTextColor 
	i1.Name=rs()
	i1.Parent=i2
	i2.BackgroundTransparency=0 
	i2.TextTransparency=1 
	i2.Size=u2(1,0,0,14) 
	i2.Name=rs() 
	if f then 
		i2.MouseButton1Click:Connect(f) 
	end 
	i2.Parent=i3 
	return i1
end
local function lbl(txt)
	local i1=i("TextBox") 
	local i2=i("Frame") 
	i1.Font=e.Font.SourceSans 
	i1.FontSize=e.FontSize.Size14 
	i1.Text=txt 
	i1.ClearTextOnFocus=false 
	i1.TextColor3=guiTheme.labelsTextColor 
	i1.Position=u2(0.5,0,0.5) 
	i1.BackgroundTransparency=1 
	i1.Name=rs() 
	i1.Parent=i2 
	i2.Size=u2(1,0,0,14) 
	i2.BackgroundTransparency=1 
	i2.Name=rs() 
	i2.Parent=i3 
	return i1
end

Draggable(i1)

lbl("by MyWorld and Chip And bobloxmanlol")

local allowshiftlock=nil
local ctrltp=nil
local placeholders=nil
local clickfling=nil
local highlightflingtargets=nil
local claimwait=nil
local discharscripts=nil

local c=nil
local function stopreanimate() 
	if c then
		c=nil
		twait()
		return true
	end
	return false
end
local function reanimate()


	local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them
	local placeholders = placeholders --makes client sided accessories replacing the real ones when unavailable
	local speedlimit = 3000 --makes your parts move slower if the magnitude of their velocity is higher than this
	local retVelTime = 0.51 --time that claimed parts have velocity to reclaim in case u lose them
	local walkSpeed = 25 --your walkspeed (can be changed at runtime)
	local jumpPower = 50 --your jump power (can be changed at runtime)
	local allowshiftlock = allowshiftlock --allows the user to use shiftlock (can be changed at runtime)
	local gravity = 196.2 --how fast the characters velocity decreases while falling (can be changed at runtime)
	local ctrlclicktp = ctrltp --makes you teleport where u point ur mouse cursor at when click and hold ctrl down
	local clickfling = clickfling --makes you fling the person you clicked when its available to do so
	local flingvel = v3(15000,16000,15000) --the rotation velocity that ur character will have while flinging
	local highlightflingtargets = highlightflingtargets --highlights characters that are going to get flung

	if stopreanimate() then return end
	c=lp.Character
	if not (c and c:IsDescendantOf(ws)) then return end

	local rootpart=gp(c,"HumanoidRootPart","BasePart") or gp(c,"Torso","BasePart") or gp(c,"UpperTorso","BasePart") or timegp(c,"HumanoidRootPart","BasePart",0.5) or c:FindFirstChildWhichIsA("BasePart")
	if not rootpart then return end

	local cam=nil
	--theres a way to have ws.currentcamera nil on heartbeat and still have the game run normally
	local function refcam()
		cam=ws.CurrentCamera
		while not cam do
			ws:GetPropertyChangedSignal("CurrentCamera"):Wait()
			cam=ws.CurrentCamera
		end
	end
	refcam()
	local camcf=cam.CFrame
	local enumCamS=e.CameraType.Scriptable
	local camt=cam.CameraType
	local camcon0=nil
	local camcon1=nil
	local camcon2=nil
	local function onnewcamera()
		refcam()
		if camcon0 then 
			camcon0:Disconnect()
			camcon1:Disconnect()
			camcon0=nil
		end
		if not c then 
			if cam.CameraType==enumCamS then
				cam.CameraType=camt
			end
			return camcon2:Disconnect() 
		end
		camcon0=cam:GetPropertyChangedSignal("CFrame"):Connect(function()
			if cam.CFrame~=camcf then
				cam.CFrame=camcf
			end
		end)
		camcon1=cam:GetPropertyChangedSignal("CameraType"):Connect(function()
			if cam.CameraType~=enumCamS then
				cam.CameraType=enumCamS
			end
		end)
		if cam.CameraType~=enumCamS then
			cam.CameraType=enumCamS
		end
		if cam.CFrame~=camcf then
			cam.CFrame=camcf
		end
	end
	camcon2=ws:GetPropertyChangedSignal("CurrentCamera"):Connect(onnewcamera)
	onnewcamera()

	local rGravity=ws.Gravity
	ws:GetPropertyChangedSignal("Gravity"):Connect(function()
		rGravity=ws.Gravity
	end)

	local fpdh=ws.FallenPartsDestroyHeight
	novoid=novoid and (fpdh+1)

	local Yvel=0
	local cfr=rootpart.CFrame
	local pos=cfr.Position
	local primarypart=nil
	local shiftlock=false
	local firstperson=false
	local xzvel=v3_0
	local v3_0150=v3_010*1.5
	local camoff=cf(v3_0,camcf.LookVector)
	camoff=camoff-v3_001*(camcf.Position-(pos+v3_0150)).Magnitude

	local R6parts={ 
		head={Name="Head"},
		torso={Name="Torso"},
		root={Name="HumanoidRootPart"},
		leftArm={Name="Left Arm"},
		rightArm={Name="Right Arm"},
		leftLeg={Name="Left Leg"},
		rightLeg={Name="Right Leg"}
	}
	rootpart=R6parts.root
	local cframes={}
	for i,v in pairs(R6parts) do
		cframes[v]=cfr
	end
	local joints={
		{
			Name="Neck",
			Part0=R6parts.torso,Part1=R6parts.head,
			C0=cf(0,1,0,-1,0,0,0,0,1,0,1,-0),
			C1=cf(0,-0.5,0,-1,0,0,0,0,1,0,1,-0)
		},
		{
			Name="RootJoint",
			Part0=rootpart,Part1=R6parts.torso,
			C0=cf(0,0,0,-1,0,0,0,0,1,0,1,-0),
			C1=cf(0,0,0,-1,0,0,0,0,1,0,1,-0)
		},
		{
			Name="Right Shoulder",
			Part0=R6parts.torso,Part1=R6parts.rightArm,
			C0=cf(1,0.5,0,0,0,1,0,1,-0,-1,0,0),
			C1=cf(-0.5,0.5,0,0,0,1,0,1,-0,-1,0,0)
		},
		{
			Name="Left Shoulder",
			Part0=R6parts.torso,Part1=R6parts.leftArm,
			C0=cf(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
			C1=cf(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)
		},
		{
			Name="Right Hip",
			Part0=R6parts.torso,Part1=R6parts.rightLeg,
			C0=cf(1,-1,0,0,0,1,0,1,-0,-1,0,0),
			C1=cf(0.5,1,0,0,0,1,0,1,-0,-1,0,0)
		},
		{
			Name="Left Hip",
			Part0=R6parts.torso,Part1=R6parts.leftLeg,
			C0=cf(-1,-1,0,0,0,-1,0,1,0,1,0,0),
			C1=cf(-0.5,1,0,0,0,-1,0,1,0,1,0,0)
		}
	}

	local refreshedjoints={}
	local refreshjointsI=nil
	refreshjointsI=function(part)
		tinsert(refreshedjoints,part)
		for i,v in pairs(joints) do
			local part0=v.Part0
			local part1=v.Part1
			if part1 and (part0==part) then
				cframes[part1]=cframes[part]*v.C0*v.C1:Inverse()
				if not tfind(refreshedjoints,part1) then
					refreshjointsI(part1)
				end
			elseif part0 and (part1==part) then
				cframes[part0]=cframes[part]*v.C1*v.C0:Inverse()
				if not tfind(refreshedjoints,part0) then
					refreshjointsI(part0)
				end
			end
		end
	end
	refreshjointsI(rootpart)
	tclear(refreshedjoints)

	local attachments={
		RightShoulderAttachment={R6parts.rightArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
		RightGripAttachment={R6parts.rightArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
		LeftFootAttachment={R6parts.leftLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
		LeftShoulderAttachment={R6parts.leftArm,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
		LeftGripAttachment={R6parts.leftArm,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
		RootAttachment={rootpart,cf(0,0,0,1,0,0,0,1,0,0,0,1)},
		RightFootAttachment={R6parts.rightLeg,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
		NeckAttachment={R6parts.torso,cf(0,1,0,1,0,0,0,1,0,0,0,1)},
		BodyFrontAttachment={R6parts.torso,cf(0,0,-0.5,1,0,0,0,1,0,0,0,1)},
		BodyBackAttachment={R6parts.torso,cf(0,0,0.5,1,0,0,0,1,0,0,0,1)},
		LeftCollarAttachment={R6parts.torso,cf(-1,1,0,1,0,0,0,1,0,0,0,1)},
		RightCollarAttachment={R6parts.torso,cf(1,1,0,1,0,0,0,1,0,0,0,1)},
		WaistFrontAttachment={R6parts.torso,cf(0,-1,-0.5,1,0,0,0,1,0,0,0,1)},
		WaistCenterAttachment={R6parts.torso,cf(0,-1,0,1,0,0,0,1,0,0,0,1)},
		WaistBackAttachment={R6parts.torso,cf(0,-1,0.5,1,0,0,0,1,0,0,0,1)},
		HairAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
		HatAttachment={R6parts.head,cf(0,0.6,0,1,0,0,0,1,0,0,0,1)},
		FaceFrontAttachment={R6parts.head,cf(0,0,-0.6,1,0,0,0,1,0,0,0,1)},
		FaceCenterAttachment={R6parts.head,cf(0,0,0,1,0,0,0,1,0,0,0,1)}
	}

	local function getPart(name,blacklist)
		for i,v in pairs(cframes) do
			if (i.Name==name) and not (blacklist and tfind(blacklist,i)) then
				return i
			end
		end
		return nil
	end

	local function getJoint(name)
		for i,v in pairs(joints) do
			if v.Name==name then
				return v
			end
		end
		return {C0=cf_0,C1=cf_0}
	end

	local function getPartFromMesh(m,t,blacklist)
		if blacklist then
			for v,_ in pairs(cframes) do
				if v.m and (not tfind(blacklist,v)) and sfind(v.m,m) and sfind(v.t,t) then
					return v
				end
			end
		else
			for v,_ in pairs(cframes) do
				if v.m and sfind(v.m,m) and sfind(v.t,t) then
					return v
				end
			end
		end
		local p={m=m,t=t}
		cframes[p]=cfr
		local j={C0=cf_0,C1=cf_0,Part0=p}
		p.j=j
		return p
	end

	local function getPartJoint(p)
		if cframes[p] then
			local j=p.j
			if j then
				return j
			end
			for i,v in pairs(joints) do
				if v.Part0==p then
					return v
				end
			end
			for i,v in pairs(joints) do
				if v.Part1==p then
					return v
				end
			end
		end
		return nil
	end

	local function getAccWeldFromMesh(m,t)
		return getPartJoint(getPartFromMesh(m,t))
	end

	local raycastparams=RaycastParams.new()
	raycastparams.FilterType=e.RaycastFilterType.Blacklist
	raycastparams.RespectCanCollide=true
	local rayfilter={}
	local characters={}
	local function refreshrayfilter()
		tclear(rayfilter)
		for i,v in pairs(characters) do
			tinsert(rayfilter,v)
		end
		raycastparams.FilterDescendantsInstances=rayfilter
	end
	local flingtable={}
	local rootparts={}
	for i=1,#accessorylimbs do
		accessorylimbs[i].a=nil
	end
	local ondes=nil
	ondes=function(v)
		local meshid,textureid=getMeshOfPart(v)
		if meshid and v.Parent~=c then
			local found=false
			for i,v1 in pairs(cframes) do
				if (meshid==i.m) and (textureid==i.t) then
					local p=i.p
					if p and p:IsDescendantOf(ws) then
						if v==p then
							found=true
							break
						end
					else
						found=true
						i.p=v
						break
					end
				else
					local j=i.j
					if j and sfind(meshid,i.m) and sfind(textureid,i.t) then
						i.m=meshid
						i.t=textureid
						i.l=v.Position
						i.p=v
						i.j=nil
						i.Name=v.Name
						local att0=v:FindFirstChildOfClass("Attachment") or (stepped:Wait() and v:FindFirstChildOfClass("Attachment"))
						if att0 then
							local att1=attachments[att0.Name] or attachments.HatAttachment
							j.C0=att0.CFrame
							j.C1=att1[2]
							j.Part1=att1[1]
						else
							j.C0=cf_0
							j.C1=cf(0,0.6,0)
							j.Part1=R6parts.head
						end
						tinsert(joints,j)
						found=true
						break
					end
				end
			end
			if not found then
				local t={Name=v.Name,l=v.Position,m=meshid,t=textureid,p=v}
				if placeholders then
					t.v=makeplaceholder(v)
				end
				cframes[t]=v.CFrame
				local j={Part0=t}
				for i=1,#accessorylimbs do
					local v=accessorylimbs[i]
					if (not v.a) and sfind(meshid,v.meshid) and sfind(textureid,v.textureid) then
						local p=getPart(v.Name)
						if p then
							j.C0=v.C0
							j.C1=cf_0
							j.Part1=p
							v.a=true
							found=true
							break
						end
					end
				end
				if not found then
					local att0=v:FindFirstChildOfClass("Attachment") or (stepped:Wait() and v:FindFirstChildOfClass("Attachment"))
					if att0 then
						local att1=attachments[att0.Name] or attachments.HatAttachment
						j.C0=att0.CFrame
						j.C1=att1[2]
						j.Part1=att1[1]
					else
						j.C0=cf_0
						j.C1=cf(0,0.6,0)
						j.Part1=R6parts.head
					end
				end
				tinsert(joints,j)
			end
		elseif v:IsA("SpecialMesh") then
			ondes(v.Parent)
		end
	end

	local function onplayer(v)
		local lastc=nil
		local function oncharacter()
			local newc=v.Character
			if c and newc and (newc~=lastc) then
				lastc=newc
				characters[v]=newc
				refreshrayfilter()
				if v==lp then
					if discharscripts then
						newc.DescendantAdded:Connect(discharscripts)
						for i,v in pairs(newc:GetDescendants()) do
							if v:IsA("Script") then
								v.Disabled=true
							end
						end
					end
					local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
					if not (hrp and c and newc:IsDescendantOf(ws)) then return end
					c=newc
					local fi,fv=next(flingtable)
					if fi then
						for i,v in pairs(tclone(flingtable)) do
							if not c then
								return
							end
							local startpos=i.Position
							local stoptime=sine+3
							while true do
								twait()
								if sine>stoptime then
									break
								end
								if (startpos-i.Position).Magnitude>200 then
									break
								end
								local tcf=i.CFrame+i.Velocity*(sin(sine*15)+1)
								if novoid and (tcf.Y<novoid) then
									tcf=tcf+v3_010*(novoid-tcf.Y)
								end
								hrp.CFrame=tcf
								hrp.Velocity=i.Velocity*v3_101*75
								hrp.RotVelocity=flingvel
							end
							if v then
								v:Destroy()
							end
							flingtable[i]=nil
						end
						hrp.Velocity=v3_0
						hrp.RotVelocity=v3_0
						hrp.CFrame=cfr
						twait(0.26)
					end
					local startpos=pos+v3(mrandom(-32,32),0,mrandom(-32,32))
					local dir=nil
					local poscheck=true
					while poscheck do
						poscheck=false
						for i,v in pairs(rootparts) do
							local diff=(startpos-v.Position)*v3_101
							if diff.Magnitude<10 then
								poscheck=true
								dir=dir or diff.Unit
								startpos=startpos+dir
							end
						end
						local diff=(startpos-pos)*v3_101
						if diff.Magnitude<10 then
							poscheck=true
							dir=dir or diff.Unit
							startpos=startpos+dir
						end
					end
					startpos=cfr.Rotation+startpos
					primarypart=c.PrimaryPart or hrp
					hrp.CFrame=startpos
					hrp.Velocity=v3_0
					hrp.RotVelocity=v3_0
					if claimwait then
						twait(0.26)
					else
						lp.Character=nil
					end
					newc:BreakJoints()
					local cd=newc:GetDescendants()
					for i=1,#cd do
						tspawn(ondes,cd[i])
					end
					newc.DescendantAdded:Connect(ondes)
				else
					local hrp=timegp(newc,"HumanoidRootPart","BasePart",10)
					if hrp and c and newc:IsDescendantOf(ws) then
						rootparts[v]=hrp
					end
				end
			end
		end
		v:GetPropertyChangedSignal("Character"):Connect(oncharacter)
		oncharacter()
	end
	local plrst=plrs:GetPlayers()
	for i=1,#plrst do onplayer(plrst[i]) end
	plrs.PlayerAdded:Connect(onplayer)
	plrs.PlayerRemoving:Connect(function(v)
		characters[v]=nil
		rootparts[v]=nil
	end)

	local mradN05=rad(-0.5)
	local KeyCode=e.KeyCode
	local enumMLC=e.MouseBehavior.LockCenter
	local enumMB2=e.UserInputType.MouseButton2
	local enumMLCP=e.MouseBehavior.LockCurrentPosition
	local enumMD=e.MouseBehavior.Default
	local enumMW=e.UserInputType.MouseWheel
	if uis.TouchEnabled then
		enumMB2=e.UserInputType.MouseButton1
	end

	local mouseBehavior=nil
	local lastMouseBehavior=uis.MouseBehavior
	uis:GetPropertyChangedSignal("MouseBehavior"):Connect(function()
		if mouseBehavior and (uis.MouseBehavior~=mouseBehavior) then
			uis.MouseBehavior=mouseBehavior
		end
	end)

	local mode="default"
	local defaultmode={}
	local modes={default=defaultmode}

	local lerpsIdle=emptyfunction
	local lerpsWalk=emptyfunction
	local lerpsJump=emptyfunction
	local lerpsFall=emptyfunction

	local function addmode(key,mode)
		if (type(key)~="string") or (type(mode)~="table") then
			return
		end
		for i,v in pairs(mode) do
			if type(v)~="function" then
				mode[i]=nil
			end
		end
		if key=="default" then
			defaultmode=mode
			modes.default=mode
			lerpsIdle=mode.idle or emptyfunction
			lerpsWalk=mode.walk or emptyfunction
			lerpsJump=mode.jump or emptyfunction
			lerpsFall=mode.fall or emptyfunction
			if mode.modeEntered then
				mode.modeEntered()
			end
		elseif #key==1 then
			key=KeyCode[supper(ssub(key,1,1))]
			modes[key]=mode
		end
	end

	local keyW=KeyCode.W
	local Wpressed=uis:IsKeyDown(keyW)
	local keyA=KeyCode.A
	local Apressed=uis:IsKeyDown(keyA)
	local keyS=KeyCode.S
	local Spressed=uis:IsKeyDown(keyS)
	local keyD=KeyCode.D
	local Dpressed=uis:IsKeyDown(keyD)
	local keySpace=KeyCode.Space
	local spacePressed=uis:IsKeyDown(keySpace)

	local keyShift=KeyCode.LeftShift
	uis.InputBegan:Connect(function(a)
		if gs.MenuIsOpen or uis:GetFocusedTextBox() then
			return
		end
		a=a.KeyCode
		if a==keyW then
			Wpressed=true
		elseif a==keyA then
			Apressed=true
		elseif a==keyS then
			Spressed=true
		elseif a==keyD then
			Dpressed=true
		elseif a==keySpace then
			spacePressed=true
		elseif a==keyShift then
			shiftlock=allowshiftlock and not shiftlock
		elseif modes[a] then
			if modes[mode].modeLeft then
				modes[mode].modeLeft()
			end
			if mode==a then
				mode="default"
			else
				mode=a
			end
			local modet=modes[mode]
			lerpsIdle=modet.idle or defaultmode.idle or emptyfunction
			lerpsWalk=modet.walk or defaultmode.walk or emptyfunction
			lerpsJump=modet.jump or defaultmode.jump or emptyfunction
			lerpsFall=modet.fall or defaultmode.fall or emptyfunction
			if modes[mode].modeEntered then
				modes[mode].modeEntered()
			end
		end
	end)
	uis.InputEnded:Connect(function(a)
		a=a.KeyCode
		if a==keyW then
			Wpressed=false
		elseif a==keyA then
			Apressed=false
		elseif a==keyS then
			Spressed=false
		elseif a==keyD then
			Dpressed=false
		elseif a==keySpace then
			spacePressed=false
		end
	end)
	uis.InputChanged:Connect(function(a,b)
		if (not b) and (a.UserInputType==enumMW) then
			camoff=camoff+a.Position*v3_001*(0.75-camoff.Z/4)
			if camoff.Z>0 then
				camoff=camoff-camoff.Position
			end
			firstperson=camoff.Z==0
		end
	end)

	local function predictionfling(target)
		if not c then
			return twait() and false
		end
		if typeof(target)~="Instance" then 
			target=mouse.Target
			if not target then
				return twait() and false
			end
		end
		if target:IsA("Humanoid") or target:IsA("BasePart") then 
			target=target.Parent 
			if target:IsA("Accessory") then
				target=target.Parent
			end
		end
		if (not target:IsA("Model")) or (target==c) then
			return twait() and false
		end
		local targetpart=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart")
		if not (targetpart and targetpart:IsDescendantOf(ws)) then
			return twait() and false
		end
		if highlightflingtargets then
			local h=i("Highlight")
			h.Name=rs()
			h.Adornee=target
			h.FillColor=c3(1,0,0)
			h.OutlineColor=c3(1,0,0)
			h.FillTransparency=0.5
			h.OutlineTransparency=0
			h.Parent=i9
			flingtable[targetpart]=h
		else
			flingtable[targetpart]=false
		end
		twait()
		return true
	end

	if ctrlclicktp then
		ctrlclicktp=KeyCode.LeftControl
		local tpoff=v3_010*3
		if clickfling then
			mouse.Button1Down:Connect(function()
				if mouse.Target then
					if uis:IsKeyDown(ctrlclicktp) then
						pos=mouse.Hit.Position+tpoff
						cfr=cf(pos,pos+camoff.LookVector*v3_101)
						xzvel=v3_0
						Yvel=0
					else
						predictionfling()
					end
				end
			end)
		else
			mouse.Button1Down:Connect(function()
				if mouse.Target and uis:IsKeyDown(ctrlclicktp) then
					pos=mouse.Hit.Position+tpoff
					cfr=cf(pos,pos+camoff.LookVector*v3_101)
					xzvel=v3_0
					Yvel=0
				end
			end)
		end
	elseif clickfling then
		mouse.Button1Down:Connect(predictionfling)
	end

	local noYvelTime=1
	local lastsine=sine
	local con=nil
	local function mainFunction()
		if not c then 
			for i,v in pairs(cframes) do
				local p=i.v
				if p then
					p:Destroy()
				end
			end
			for i,v in pairs(flingtable) do
				if v then
					v:Destroy()
				end
			end
			mouseBehavior=nil
			uis.MouseBehavior=enumMD
			onnewcamera()
			local c=lp.Character
			if c then
				cam.CameraSubject=c:FindFirstChildOfClass("Humanoid")
			end
			return con and con:Disconnect() 
		end

		sine=osclock()
		local delta=sine-lastsine
		deltaTime=clamp(delta*10,0,1)
		lastsine=sine

		if shiftlock then
			if allowshiftlock then
				mouseBehavior=enumMLC
				local rotation=uis:GetMouseDelta()*mradN05
				local camoffpos=camoff.Position
				camoff=cf(camoffpos,camoffpos+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
			else
				shiftlock=false
			end
		elseif firstperson then
			mouseBehavior=enumMLC
			local rotation=uis:GetMouseDelta()*mradN05
			local camoffpos=camoff.Position
			camoff=cf(camoffpos,camoffpos+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
		elseif uis:IsMouseButtonPressed(enumMB2) then
			mouseBehavior=enumMLCP
			local rotation=uis:GetMouseDelta()*mradN05
			local camoffpos=camoff.Position
			camoff=cf(camoffpos,camoffpos+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
		else
			mouseBehavior=enumMD
		end
		if lastMouseBehavior~=mouseBehavior then
			lastMouseBehavior=mouseBehavior
			uis.MouseBehavior=mouseBehavior
		end

		local raycastresult=ws:Raycast(pos,v3_010*(fpdh-pos.Y),raycastparams)
		local onground=nil
		if raycastresult then
			raycastresult=raycastresult.Position
			onground=(pos.Y-raycastresult.Y)<3.01
			if onground then
				Yvel=0
				cfr=cfr+v3_010*(raycastresult.Y+3-pos.Y)*clamp(delta*20,0,1)
				if spacePressed then
					Yvel=jumpPower
				end
			else
				Yvel=Yvel-gravity*delta
				if pos.Y+Yvel*delta<raycastresult.Y then
					Yvel=0
					cfr=cfr+v3_010*(raycastresult.Y+3-pos.Y)
				end
			end
		else
			Yvel=0
			onground=false
		end
		xzvel=v3_0
		if Wpressed then
			xzvel=xzvel+(camoff.LookVector*v3_101).Unit
		end
		if Spressed then
			xzvel=xzvel-(camoff.LookVector*v3_101).Unit
		end
		if Apressed then
			xzvel=xzvel-(camoff.RightVector*v3_101).Unit
		end
		if Dpressed then
			xzvel=xzvel+(camoff.RightVector*v3_101).Unit
		end
		pos=cfr.Position
		if shiftlock or firstperson then
			if xzvel.Magnitude>0 then
				xzvel=xzvel.Unit*walkSpeed
			end
			cfr=cf(pos,pos+camoff.LookVector*v3_101)
		elseif xzvel.Magnitude>0 then
			xzvel=xzvel.Unit*walkSpeed
			cfr=cfr:Lerp(cf(pos,pos+xzvel),deltaTime)
		end
		cfr=cfr+(xzvel+(v3_010*Yvel))*delta
		pos=cfr.Position

		camcf=cf(pos,pos+camoff.LookVector)+camoff.LookVector*camoff.Z+v3_0150
		if shiftlock and not firstperson then
			camcf=camcf+camcf.RightVector*1.75
		end
		if cam then
			cam.CFrame=camcf
		end

		cframes[rootpart]=cfr

		if onground then
			if xzvel==v3_0 then
				lerpsIdle()
			else
				lerpsWalk()
			end
		elseif Yvel>0 then
			lerpsJump()
		else
			lerpsFall()
		end

		refreshjointsI(rootpart)
		tclear(refreshedjoints)

		if abs(Yvel)>1 then
			noYvelTime=0
		else
			noYvelTime=clamp(noYvelTime+delta*0.3,0,1)
			xzvel=xzvel*(1-noYvelTime)
		end

		local idlerv=v3(sin((sine-0.0375)*16),sin(sine*16),sin((sine+0.075)*16))
		local idleoff=idlerv*0.001

		local claimpos=primarypart.Position
		for i,v in pairs(cframes) do
			local part=i.p
			if part and (not part.Anchored) and part:IsDescendantOf(ws) then
				if part.ReceiveAge==0 then
					local placeholder=i.v
					if placeholder then
						placeholder.Parent=nil
					end
					if novoid and (v.Y<novoid) then
						v=v+v3_010*(novoid-v.Y)
					end
					local lastpos=i.l
					local vel=(v.Position-lastpos)/delta
					if vel.Magnitude>speedlimit then
						vel=vel.Unit*speedlimit
						v=v+(lastpos+vel*delta)-v.Position
					end
					i.l=v.Position
					if vel.Magnitude<0.15 then
						v=v+idleoff
					end
					local claimtime=i.c
					if claimtime then
						if sine-claimtime<retVelTime then
							part.Velocity=(claimpos-v.Position)*v3_101/getFallingTime(v.Y,claimpos.Y,rGravity)+v3_net
						else
							part.Velocity=getNetlessVelocity(vel*noYvelTime+xzvel)
						end
					else
						i.c=sine
						part.Velocity=getNetlessVelocity(vel*noYvelTime+xzvel)
					end
					part.CFrame=v
					part.RotVelocity=idlerv
				else
					i.c=nil
					i.l=part.Position
					local placeholder=i.v
					if placeholder then
						placeholder.Parent=ws
						placeholder.CFrame=v
					end
				end
			else
				local placeholder=i.v
				if placeholder then
					placeholder.Parent=ws
					placeholder.CFrame=v
				end
			end
		end
	end

	sine=osclock()
	lastsine=sine
	con=heartbeat:Connect(mainFunction)
	mainFunction()

	local function refreshjoints(v) --use this on the main part if u have parts that
		refreshjointsI(v) --are connected with each other but arent connected to rootpart
		tclear(refreshedjoints)
	end

	local legcfR=cf(1,-1,0)
	local legcfL=cf(-1,-1,0)
	local raydir=v3_010*-2
	local function raycastlegs() --this returns 2 values: right leg raycast offset, left leg raycast offset
		local rY=ws:Raycast((cfr*legcfR).Position,raydir,raycastparams)
		local lY=ws:Raycast((cfr*legcfL).Position,raydir,raycastparams)
		return rY and (rY.Position.Y-(pos.Y-3)) or 0,lY and (lY.Position.Y-(pos.Y-3)) or 0
	end

	local function velbycfrvec() --this returns 2 values: forward/backwards movement (from -1 to 1), right/left movement (from -1 to 1)
		local fw=cfr.LookVector*xzvel/walkSpeed
		local rt=cfr.RightVector*xzvel/walkSpeed
		return fw.X+fw.Z,rt.X+rt.Z
	end

	local lastvel=v3_0
	local velchg1=v3_0
	local function velchgbycfrvec() --this returns 2 values: forward/backwards velocity change, right/left velocity change
		velchg1=velchg1+(lastvel-xzvel) --i recommend setting velchg1 to v3_0 when u start using this function or it will look worse
		lastvel=xzvel
		velchg1=velchg1:Lerp(v3_0,deltaTime/2)
		local fw=cfr.LookVector*velchg1/32
		local rt=cfr.RightVector*velchg1/32
		return fw.X+fw.Z,rt.X+rt.Z
	end

	local lastYvel=0
	local velYchg1=0
	local function velYchg() --this returns Y axis velocity change
		velYchg1=clamp(velYchg1+(lastYvel-Yvel),-50,50) --i recommend setting velYchg1 to 0 when u start using this function or it will look worse
		lastYvel=Yvel
		velYchg1=velYchg1-velYchg1*(deltaTime/2)
		return velYchg1
	end

	local function rotToMouse(alpha) --this rotates ur character towards your mouse hit position
		local mpos=mouse.Hit.Position
		cfr=cfr:Lerp(cf(pos,v3(mpos.X,pos.Y,mpos.Z)),alpha or deltaTime)
	end

	local function setWalkSpeed(n)
		if type(n)~="number" then
			n=16
		end
		walkSpeed=n
	end
	local function setJumpPower(n)
		if type(n)~="number" then
			n=50
		end
		jumpPower=n
	end
	local function setGravity(n)
		if type(n)~="number" then
			n=196.2
		end
		gravity=n
	end

	return {
		cframes=cframes,
		joints=joints,
		fling=predictionfling,
		predictionfling=predictionfling,
		refreshjoints=refreshjoints,
		raycastlegs=raycastlegs,
		velbycfrvec=velbycfrvec,
		velchgbycfrvec=velchgbycfrvec,
		velYchg=velYchg,
		addmode=addmode,
		getPart=getPart,
		getPartFromMesh=getPartFromMesh,
		getAccWeldFromMesh=getAccWeldFromMesh,
		getJoint=getJoint,
		getPartJoint=getPartJoint,
		rotToMouse=rotToMouse,
		setWalkSpeed=setWalkSpeed,
		setJumpPower=setJumpPower,
		setGravity=setGravity
	}
end


btn("VR", function()
	local t=reanimate()
	if type(t)~="table" then return end
	local raycastlegs=t.raycastlegs
	local velbycfrvec=t.velbycfrvec
	local addmode=t.addmode
	local getJoint=t.getJoint
	local velYchg=t.velYchg
	local setWalkSpeed=t.setWalkSpeed
	local RootJoint=getJoint("RootJoint")
	local RightShoulder=getJoint("Right Shoulder")
	local LeftShoulder=getJoint("Left Shoulder")
	local RightHip=getJoint("Right Hip")
	local LeftHip=getJoint("Left Hip")
	local Neck=getJoint("Neck")

	addmode("default", {
		idle = function()
			local rY, lY = raycastlegs()

			local Ychg=velYchg()/20



LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin(sine*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 

end,
		walk = function()
			local Vfw, Vrt = velbycfrvec()

			local rY, lY = raycastlegs()

			local Ychg=velYchg()/20



LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 


end,
		jump = function()
			velYchg()
			local Vfw, Vrt = velbycfrvec()



LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.8,-1+0.1*sin(sine*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),0.6+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.8,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 


end,
		fall = function()
			velYchg()
			local Vfw, Vrt = velbycfrvec()



LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 


end
	})

	addmode("q", {
		idle = function()
			velYchg()

RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.7453292519943295,0,3.141592653589793+0.4363323129985824*sin(sine*10))),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 

end
	})
	addmode("e", {
		idle = function()
			velYchg()


LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.4,0.1 * sin((sine+1)*1)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(2.5+0.1*sin((sine+1)*1),1,-1+0.1*sin((sine+1)*1)),angles(2.9670597283903604,3.141592653589793,0.3490658503988659*sin((sine+1)*5))),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.9198621771937625,0,3.141592653589793)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
end
	})
	addmode("r", {
		idle = function()
			local Ychg=velYchg()/20


RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.5707963267948966,3.141592653589793,0.7853981633974483)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.1 * sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(1+0.1*sin(sine*1),1+0.1*sin(sine*1),-1+0.1*sin(sine*1)),angles(-1.5707963267948966,0.17453292519943295,3.490658503988659)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5,-0.4,-1),angles(1.5707963267948966,3.141592653589793,-0.7853981633974483)),deltaTime) 
end
	})
	addmode("t", {
		idle = function()
			local Ychg=velYchg()/20


RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.7453292519943295+0.4363323129985824*sin(sine*10),0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.4,-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 


end
	})
	addmode("y", {
		idle = function()
			local Ychg=velYchg()/20


RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5+0.1*sin((sine+1)*1),-0.4+0.5*sin(sine*5),-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.7453292519943295+0.17453292519943295*sin(sine*10),0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5+0.1*sin((sine+1)*1),-0.4+0.5*sin((sine+2)*5),-1+0.1*sin((sine+1)*1)),angles(1.3962634015954636,3.141592653589793,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 


end
	})
	addmode("u", {
		idle = function()
			velYchg()


RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-0.8+0.1*sin((sine+1)*1),-0.4,-1.5+0.1*sin((sine+1)*1)),angles(1.9198621771937625,3.141592653589793,0.5235987755982988*sin(sine*15))),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.7453292519943295,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(0.8+0.1*sin((sine+1)*1),-0.4,-1.5+0.1*sin((sine+1)*1)),angles(1.9198621771937625,3.141592653589793,0.5235987755982988*sin((sine+1)*15))),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 

end
	})
	addmode("i", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end,
	})
	addmode("o", {
		idle = function()
			local Ychg=velYchg()/20
			local rY, lY = raycastlegs()

LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end,
		walk = function()
			local Ychg=velYchg()/20
			local Vfw, Vrt = velbycfrvec()

			local rY, lY = raycastlegs()

LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	addmode("p", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	addmode("f", {
		modeEntered = function()
			setWalkSpeed(25)
		end,
		idle = function()
			velYchg()

RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1+0.1*sin(sine*1),0.1 * sin(sine*1)),angles(-1.7453292519943295,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1,-0.4,-1+0.5*sin(sine*20)),angles(1.7453292519943295,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.1 * sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,-0.4,-1+0.5*sin((sine+2)*20)),angles(1.7453292519943295,3.141592653589793,0)),deltaTime) 

end,
		walk = function()
			velYchg()
			local Vfw, Vrt = velbycfrvec()
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end,
		modeLeft = function()
			setWalkSpeed(16)
		end,
	})
	addmode("g", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	addmode("h", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	addmode("j", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	addmode("k", {
		idle = function()
			local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	})
	local function idleL()
		local Ychg=velYchg()/20
LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.7+0.1*sin(sine*2),0.5,1),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,1,0),angles(0,1.5707963267948966,0)),deltaTime) 
Neck.C0=Lerp(Neck.C0,cfMul(cf(0.1 * sin(sine*1),1.5+0.1*sin(sine*1),-0.3+0.1*sin(sine*1)),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.7+0.1*sin((sine+1)*2),0.5,1+0.1*sin((sine+1)*2)),angles(-0.3490658503988659,3.141592653589793,0)),deltaTime) 
RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.5+0.1*sin(sine*1.2),0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
end
	addmode("l", {
		modeEntered = function()
			setWalkSpeed(10)
		end,
		idle = idleL,
		walk = idleL,
		modeLeft = function()
			setWalkSpeed(16)
		end
	})
end)

local function swtc(txt,options,onchanged)
	local current=0
	local swtcbtn=nil
	local function btnpressed()
		current=current+1
		if current>#options then
			current=1
		end
		local option=options[current]
		swtcbtn.Text=txt..": "..option.text
		onchanged(option.value)
	end
	swtcbtn=btn("change",btnpressed)
	btnpressed()
	return swtcbtn
end



local iscg,_=pcall(function()
	i9.Parent=game:FindFirstChildOfClass("CoreGui")
end)
if not iscg then
	i6.Text="PLAYERGUI MODE"
	i9.Parent=pg
	twait(3)
	i6.Text=guiTheme.guiTitle
end


swtc("allow shiftlock",{
	{value=true,text="yes"},
	{value=false,text="no"}
},function(v)
	allowshiftlock=v
end)

swtc("ctrl click tp",{
	{value=true,text="yes"},
	{value=false,text="no"}
},function(v)
	ctrltp=v
end)

swtc("click fling",{
	{value=true,text="yes"},
	{value=false,text="no"}
},function(v)
	clickfling=v
end)
